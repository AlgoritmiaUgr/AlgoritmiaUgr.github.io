# Ejercicios `<set>`

En este apartado veremos ejercicios t铆picos en los que son necesarios el uso de `sets`, sobre todo los pertenecientes a `unordered_set`.

##  Recordatorio

### Declaraci贸n:

1. `unordered_set<tipo> nombre;`
2. `set<tipo> nombre;`

### Funciones 煤tiles:

- `set.insert(x)`: inserta `x`  
- `set.erase(x)`: borra `x`  
- `set.count(x)`: devuelve `1` si `x` existe, `0` si no  
- `set.find(x)`: devuelve un iterador a `x`; si no existe, devuelve `set.end()`  
- `set.size()`: devuelve el n煤mero de elementos del set

>  Los sets son ideales para eliminar duplicados, comprobar existencia de elementos r谩pidamente y trabajar con colecciones 煤nicas.

---

## (EASY) Keating vs. Pritchard  
 [Acepta el reto - 731](https://aceptaelreto.com/problem/statement.php?id=731&cat=166)

###  Descripci贸n:
Dado un conjunto de p谩ginas arrancadas, se nos pide contar cu谩ntas hojas 煤nicas han sido arrancadas. Cada hoja contiene 2 p谩ginas (ej: p谩gina 1 y 2 pertenecen a la hoja 1).

<details>
<summary> Ver soluci贸n</summary>

```cpp
#include <iostream>
#include <unordered_set>

using namespace std;

int main() {
    int n;
    while (cin >> n && n != 0) {
        unordered_set<int> hojas_eliminadas;
        for (int i = 0; i < n; i++) {
            int pagina;
            cin >> pagina;
            // Pagina 1 -> Hoja 1
            // Pagina 2 -> Hoja 1
            // Pagina 3 -> Hoja 2
            // Pagina 4 -> Hoja 2
            // ...
            // Esto se puede generalizar como (pagina + 1) / 2
            hojas_eliminadas.insert((pagina + 1) / 2);
        }
        cout << hojas_eliminadas.size() << "\n"; // El tama帽o es el n煤mero de hojas 煤nicas
    }
    return 0;
}
```

###  Explicaci贸n:
- Cada p谩gina se asocia a una hoja mediante `(pagina + 1) / 2`
- Se insertan en un `unordered_set`, que evita duplicados
- Finalmente, el tama帽o del set indica cu谩ntas hojas distintas se arrancaron

</details>

---

## (EASY) 217. Contains Duplicate  
 [Leetcode - Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

###  Descripci贸n:
Dado un array de enteros, determina si alguno de sus valores aparece al menos dos veces.

<details>
<summary> Soluci贸n 1 (con Set)</summary>

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> num_set;
        for (int num : nums) {
            if (num_set.count(num)) {
                return true;
            }
            num_set.insert(num);
        }
        return false;
    }
};
```

###  Explicaci贸n:
- Se usa un `unordered_set` para llevar registro de los n煤meros que han aparecido
- Si un n煤mero ya est谩 en el set, entonces es un duplicado

</details>

<details>
<summary>锔 Soluci贸n 2 (Optimizada con sort)</summary>

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for(size_t i = 1; i < nums.size(); i++){
            if(nums[i] == nums[i-1]) return true;
        }
        return false;
    }
};
```

###  Explicaci贸n:
- Al ordenar el array, los duplicados estar谩n uno junto a otro
- Se compara cada elemento con el anterior

</details>

 Comparaci贸n de complejidades:

- **Soluci贸n 1 (Set)**: O(N) tiempo, O(N) espacio  
- **Soluci贸n 2 (Sort)**: O(N log N) tiempo, O(1) o O(log N) espacio

> 癸 Aunque la soluci贸n con `sort` parece peor en teor铆a, puede rendir mejor en la pr谩ctica debido a un mejor uso de cach茅 y operaciones m谩s r谩pidas.

---

## (EASY) 349. Intersection of Two Arrays  
 [Leetcode - Intersection](https://leetcode.com/problems/intersection-of-two-arrays/)

###  Descripci贸n:
Dado dos arrays, devuelve su intersecci贸n sin duplicados.

<details>
<summary> Ver soluci贸n</summary>

```cpp
#include <vector>
#include <unordered_set>

using namespace std;

class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<int> solucion;
        // Creamos el set a partir del vector m谩s peque帽o para optimizar
        unordered_set<int> set_nums(nums1.begin(), nums1.end());

        for (int num : nums2) {
            if (set_nums.count(num)) {
                solucion.push_back(num);
                set_nums.erase(num);
            }
        }
        return solucion;
    }
};
```

###  Explicaci贸n:
- Se construye un `unordered_set` con los elementos del primer vector
- Se recorre el segundo vector y se agrega al resultado si est谩 en el set
- Se elimina del set para evitar duplicados en la soluci贸n

</details>

---

## З Conclusi贸n

Los `set` y `unordered_set` son estructuras poderosas para resolver muchos problemas:

- Eliminan duplicados autom谩ticamente
- Permiten comprobaciones de existencia en tiempo eficiente
- Facilitan la implementaci贸n de operaciones de conjuntos como uni贸n e intersecci贸n

Aprender a usarlos correctamente te permitir谩 escribir soluciones m谩s limpias y eficientes en programaci贸n competitiva y desarrollo general.
